本調査の目的・背景
行内におけるWebシステム開発において、JavaEEモデル(以下図を参照)各層の標準化が課題となっている。現在フレームワークはBTMU-FWに標準化され、外部システム接続層は～に標準化されている。今回は未だ行内標準化されていないインテグレーション層(中でもDB接続層)をスコープとして調査を行った。尚、プレゼンテーション層の標準化については来期に調査を実施する予定である。
行内開発において、DB接続層ではJDBC、MyBatis、JPAが利用されている。本調査ではJavaEE5より標準化技術として策定されたJPAを対象とし、各種機能・生産性を調査する事でJPAがDB接続層における行内標準化技術としての妥当性を計る事を目的とする。














JPAとは
JPA(Java Persistence API)とはJavaEE5より標準化されたO/Rマッピングフレームワークであり、自動O/Rマッピングによる高い開発生産性に加えて標準API、クエリ等のDBMSに依存しないDBアクセスによる高移植性を備えている。
機能調査
O/Rマッピングの外部定義化
JPAでは、～で記載した通りエンティティクラスでアノテーションを利用してO/Rマッピングする方法が一般的だが、外部定義化する事も可能である。外部定義ファイルは永続化設定ファイル(persisetence.xml)内の<mapping-file>タグにて指定する。(デフォルトはorm.xml)また、このマッピングファイルにはO/Rマッピングだけではなくエンティティクラスと同様に名前付きクエリを定義する事も可能である。クエリを外部定義化する事により、保守性の向上が図れる。記載例を以下に示す。
ロック
JPAでは、以下の様にロック用メソッドが提供されている。
EntityManagerが提供するAPI
　・find(エンティティオブジェクト,主キーの値,ロックタイプ※)
　・lock(エンティティオブジェクト,ロックタイプ)
JPQLによるAPI
　・setLockMode(ロックタイプ)
※ロックタイプ：当パラメータにて楽観的・悲観的ロックを指定する。

楽観的ロックではSQL発行時だけではなく、エンティティクラスに以下2つの方法いずれかに対応したカラムを用意する必要がある。
バージョン番号をチェックする方法
対象テーブルに各ローのバージョン番号を表す数値型のカラムを用意する。そして、
エンティティクラスにはそのカラムとマッピングする数値型の永続フィールドを用意し以下の様にversionカラムを用意する。
@Column(name = “VERSION”)
@Version
public long getVersion()
{
  return version;
}
上記の様にする事でJPAエンジンがSQLを発行してローを更新する際、自動的にバージョン情報カラムが更新される。ローを更新する際にバージョン情報が書き換えられていた場合、JPAエンジンがjavax.persistence.OptimisticLockException例外を発行する。
最終更新時間をチェックする方法
こちらでは、最終更新時間を表す時間型のカラムを用意する。バージョン番号と同様にローを更新する際に最終更新時間カラムも更新され、ローを更新する際に他トランザクションにより既に更新されていた場合には同様にjavax.persistence.OptimisticLockException例外が発行される。以下に一例を示す。
@Column(name = “LAST_UPDATE_TIME”)
@Version
public TimeStamp getLastUpdateTime()
{
	return lastUpdateTime;
}
JPAでロックを利用する際の考慮点
JDBC、JPA間にてロックにおける差異について検討した。
楽観的ロックでは、固有のSQLを発行しない(ローの更新状態を管理するカラム(バージョン情報、更新時間等)を更新するのみ)ため、JDBC、JPA間にて考慮する必要のある差異は特にない。JDBCでは悲観的ロックはSELECT FOR UPDATE文を発行する事により実現されるが、以下例によりJPAにて悲観的ロックを利用した際に発行されるSQLを検証した。
・コード例
・ログ
上記より、悲観的ロックにおいて発行されるSQLにおいてJDBC、JPA間にて差異が無い事が確認できた為、悲観的・客観的ロックについてはJPA固有の考慮点は特に無い事が分かる。尚、ログレベルの設定(発行されるSQLのログへの出力有無)は永続化設定ファイル(persistence.xml)にて以下の様に設定する。
<properties>
<property name="eclipselink.logging.level" value="FINE"/>
</properties>
リレーションシップ
2つのエンティティクラス間の関連性はリレーションシップと呼ばれる。オブジェクトモデルではリレーションシップモデルと異なり結合という観点は存在せず、関連するオブジェクトへの参照を一方のオブジェクトのフィールドとして保有する形を取る。
リレーションシップには方向、カーディナリティという概念がある。
方向
　・単方向：一方のエンティティクラスが他方のエンティティクラスへの参照を保有する。
　・双方向：2つのエンティティクラスが互いに他方の参照を保有する。
カーディナリティ(多重度)
　カーディナリティとは、2つのエンティティクラス間のリレーションシップにおいて、一方のエンティティオブジェクトのローに関連付けられるローが他方のエンティティオブジェクトにいくつか存在するかを表す。カーディナリティには以下がある。他方のエンティティオブジェクトへの参照のゲッタにカーディナリティを表すアノテーションを付与する。
　・OnetoOne(一対一)…@OneToOne
　・OnetoMany(一対多)…@OneToMany
　・ManytoOne(多対一)…@ManyToOne
　・ManytoMany(多対多)……@ManyToMany
また、エンティティオブジェクト間を関連付けるフィールドについては、@JoinColumnアノテーションを付与する。カーディナリティがOneToManyの例を以下に示す。
ソース例：

フェッチ戦略
フェッチ戦略とはエンティティを検索する際に、DBMS上のデータを読み込むタイミングの事である。フェッチ戦略には以下イーガーフェッチ、レイジーフェッチが存在する。
フェッチ戦略の指定方法は以下の通り、エンティティクラスのフィールドにて他エンティティとのリレーションシップ定義する際に指定する。(以下はEagerフェッチの例)














イーガーフェッチ
イーガーフェッチとは、エンティティを検索する際に関連するエンティティの値を全て一度のSQLでメモリに読み込む方式である。上図では、テーブルAのあるレコード、このレコードとリレーションシップを持つテーブルBのレコードをメモリに読み込む。

レイジーフェッチ
上記に対して、レイジーフェッチではSQLを発行した際にテーブルAの当該レコードのみを取得する。テーブルBのレコードについては、実際に値を呼び出す際にSQLが発行されメモリに読み込まれる。

カスケード
　→状態遷移とかいるか？？？



事例調査
一般事例
各ベンダー(Oracle、IBM、日立、オージス)に対してヒアリングしたJPA事例調査の結果を以下表に示す。

行内事例
一般事例同様に行内(ダイレクトバンキング、売掛活用ファシリティシステム、通貨オプション販売管理システム(COO))へヒアリングした調査結果を以下表に示す。

ダイレクトバンキング
ダイレクトバンキングでは、APサーバが提供するJPAエンジンではなくOSSであるHibernateを採用し、PFWの機能の一部として利用している。
当システムでの課題としてJPAの特徴である以下2点が挙げられた。
・SQL発行のタイミングが不明瞭である(トランザクションがコミットされるタイミングでは確実に発行されるが、正確には不明瞭)
・EntityManagerによる主キー検索、JPQLを利用した場合にJPAエンジンがSQLを組み立てる為、開発者がSQLチューニングが出来ない
そのため、ダイレクトバンキングでは開発初期段階より以下の様に対策をする事で課題解決を図った。
・flushメソッドを利用する事でSQL発行のタイミングを明確化した
・ネイティブクエリを利用する事によりSQLチューニング(複雑なSQL、DBMS固有のSQL)を可能とした

売掛活用ファシリティシステム
売掛活用ファシリティシステムにおいても、JPAエンジンとしてHibernateを採用し、BTMU-Fの機能の一部として利用している。
当システムでは以下の課題に直面した。
・FETCH戦略(ユースケースにて利用しないエンティティについてもDBMSより取得してしまい、ヒープが枯渇した)
・SQL発行のタイミングが不明瞭である(エンティティを意図せず更新した(初期化等)際に発行されてしまった)
・有識者が少なく、学習コストがかかった



対策は以下の通りである。
・当該箇所につきネイティブクエリを利用
・DBMSと同期する必要なくなったタイミングにて、エンティティオブジェクトの状態を管理から分離状態へ変更する。

COO


上記調査より、機能概要で説明したJPQL・ネイティブクエリがシステムによって、使い分けされている事が分かる。～事例の様に、大量レコードを扱うが高い性能要件を要求されるシステムではDBMS固有のSQL(Oracle、HiRDB等におけるHint句等)が必要とされるため、ネイティブクエリが利用されている。

→各ベンダさん・COOにJPQL・ネイティブクエリの使い分けを調査する必要あり。
　使い分ける

導入効果の調査
開発生産性の向上
本項では、冒頭で記載したJPAのメリットの一つである開発生産性について定量的に評価する。JDBCと比較して、JPAが開発生産性を向上出来るポイントはO/Rマッピングの自動化、DBコネクション取得の不要化である。
以下にJDBC、JPAを利用したDAOのソースを記載する。

JPQL
JPQLを利用する事で主キー以外での検索、WHERE節、集合関数、結合等が可能となる。
JPQL文の実行にはJPAの提供するクエリを使用する。また、setParameter()メソッドを利用する事でWHERE節等に動的なパラメータを利用する事が出来る。
記載例を以下に示す。
名前付き

